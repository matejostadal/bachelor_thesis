\documentclass[
  program=infoi,
% printversion,
  biblatex,
  figures=false,
  glossaries,
  index
]{kidiplom}


\title{Využití prvočísel při šifrování dat}
\title[english]{Use of prime numbers in data encryption}

\author{Matěj Ošťádal}

\supervisor{doc. RNDr. Miroslav Kolařík, Ph.D.}


\annotation{TODO ANOTACE}
\annotation[english]{TODO ANOTACE ANGLICKY}

\keywords{šifrování; prvočísla; bezpečnost; modulární aritmetika; }
\keywords[english]{encryption; prime numbers; security; modular arithmetic}

\supplements{žádné}
\supplements[english]{none}

% \thanks{Děkuji, děkuji, děkuji.}

\bibliography{bibliografie.bib}

%% Další dodatečné styly (balíky) potřebné pro sazbu vlastního textu
%% práce.
\usepackage{lipsum}
\usepackage{longtable}
\usepackage{amsmath}
\usepackage{hyperref}

\begin{document}

\maketitle

%% Vlastní text závěrečné práce. Pro povinné závěry, před přílohami,
%% použijte prostředí kiconclusions. Povinná je i příloha s obsahem
%% přiloženého datového média.

%% -------------------------------------------------------------------

\newcommand{\BibLaTeX}{\textsc{Bib}\LaTeX}

\part{Úvod}\label{introduction}

    % todo inspirace A Graduate Course (projít shodu a parafrázovat)

    V celé práci budeme hledat různá řešení následujícího problému:

    \medskip
    Mějme dva uživatele, Alici a Boba, kteří si chtějí po síti poslat tajnou zprávu $m$.
    V síti je také protivník, Eva, který komunikaci odposlouchává (může zprávu zachytit). Potřebujeme zařídit, aby Eva
    nemohla zjistit obsah zprávy $m$.\footnote{Jména Alice a Bob byla poprve použita v článku 
    \emph{A method for obtaining digital signatures and public-key cryptosystems} z roku 1978.
    Jméno Eva (z angl. \emph{eavesdropper}) bylo jedno z dalších, které se v kryptografii objevilo.
    Jména nám pomáhají udržet přehlednější a jednodušší výklad.}

    Velmi zjednodušeně můžeme popsat poslání zprávy Alice Bobovi takto:
    Alice upraví zprávu $m$ (upravenou zprávu označíme $c$)\footnote{Použití písmena $m$ a $c$ plyne z angl. slov \emph{message} a \emph{cipher}.}
    a pošle ji sítí Bobovi.
    Bob přijme $c$, upraví ji do původní podoby $m$ a poté si ji přečte.
    Alice s Bobem využívají toho, že Eva neví jakým způsobem byla $m$ upravena na $c$, a tudíž nemá jak získat $m$.

    \medskip
    Tomu, co myslíme tím, že je zpráva upravována, se budeme věnovat dále.

    \bigskip
    Pro zjednodušení budeme nyní předpokládat následující:

    \begin{itemize}
        \item
            Eva není schopna modifikovat zachycenou zprávu.
            Bob tedy nebude muset kontrolovat, zda zprávu opravdu poslala Alice, a naopak
            (tohoto předpokladu se zbavíme v kapitole~\ref{public-key}).
        \item
            Alice i Bob mají možnost si zprávu přečíst v bezpečném prostředí.
    \end{itemize}

    Základní způsob úpravy zprávy budeme nazývat \emph{šifrování}. Proces úpravy zprávy $m$ na $c$
    budeme nazývat \emph{zašifrování} a proces úpravy $c$ zpět na $m$ \emph{dešifrování}.

\newpage
\part{Symetrické šifrování}\label{private-key}
    Symetrické šifrování je způsob šifrování, ve kterém je v procesu zašifrování zprávy použit
    stejný klíč \emph{k}, jako v procesu dešifrování.\footnote{Písmeno $k$ opět používáno kvůli anglickému \emph{key}.}

    % citace z Graduate Course ...

    \bigskip

    Symetrická šifra pro nás bude uspořádaná dvojice $\mathcal{E}  = (E, D)$, kde:

    \begin{itemize}
        \item
            $E$ je funkce zašifrování (E z ang. \emph{encryption}).
            $E$ přijímá na vstupu klíč $k$ a zprávu $m$.
            Jako výstup vrací zašifrovaný text $c$.

            \begin{center}
                $E: \mathcal{K} \times \mathcal{M} \rightarrow \mathcal{C}$,
            \end{center}

            kde $\mathcal{K}$ je množina klíčů, $\mathcal{M}$ je množina zpráv a 
            $\mathcal{C}$ je množina šifrovaných zpráv.

        \item
            $D$ je funkce dešifrování (D z ang. \emph{decryption}). $D$ přijímá na vstupu klíč $k$ a zašifrovaný text $c$.
            Jako výstup vrací dešifrovanou zprávu $m$.
            
            \begin{center}
                $D: \mathcal{K} \times \mathcal{C} \rightarrow \mathcal{M}$
            \end{center}

    \end{itemize}

    Každá $\mathcal{E}$ je tedy definována nad $(\mathcal{K},\mathcal{M},\mathcal{C})$.

    \medskip

    Teď už můžeme konkrétněji formulovat postup poslání zprávy mezi Alicí a Bobem:

    Alice zašifruje zprávu $m$ (tedy sestrojí $c=E(k,m)$) a pošle $c$ sítí Bobovi.
    Bob přijme $c$, rozšifruje ho (tedy získá $m=D(k,c)$), a zprávu si přečte.

    \medskip

    Všimněme si teď několika věcí:
    
    \begin{enumerate}
        \item
            Přirozeně požadujeme, aby $D(k, E(k, m))=m$.
            (Bob získá stejnou zprávu, jako poslala Alice.)
            Této podmínce budeme říkat \emph{podmínka korektnosti} a nadále se budeme
            zabývat pouze takovými šiframi, které ji splňují.
        \item
            Alice a Bob musí být předem domluveni na používaném klíči $k$.
        \item
            To, že si Eva přečte $m$ nám nevadí (z $c$ nejde snadno získat $m$)\footnote{Slovem \emph{snadno} myslíme, že získání
            $m$ z $c$ je značně výpočetně náročné. Tomuto se ještě budeme konkrétněji věnovat později.}.
        \item
            Eva nesmí znát $k$, jinak by totiž z $c$ mohla získat původní $m$.
    \end{enumerate}

    Zkusme se zamyslet nad tím, jak bychom mohli zařídit bod 2, tedy jak by se Alice mohla s Bobem
    domluvit na klíči $k$, a přitom zajistit bod 4.

    \medskip

    Určitě nás napadne, že by si Alice s Bobem mohli $k$ poslat zprávou.
    Pokud ale Eva čte všechny zprávy v síti, určitě by si mohla $k$ zapamatovat.

    Mohli bychom tedy klíč $k$ zašifrovat pomocí dalšího tajného klíče $k_2$.
    Alice by tedy sestrojila $c = E(k_2, k)$ a $c$ by poslala Bobovi.
    Bob by pomocí $D(k_2, c)$ získal $k$, který by Eva neznala.
    Tím bychom sice vyřešili náš původní problém, ale vytvořili bychom další: Jak se Alice s Bobem domluví
    na $k_2$? (Jistě nám dojde, že při použití stejného postupu by vznikal stále dokola ten samý problém.)
    
    Potřebujeme, aby se Alice s Bobem na $k$ domluvili v nějaké bezpečné síti, kterou Eva nemůže odposlouchávat.
    (Například by se mohli sejít v parku a $k$ si tajně sdělit.)\footnote{To bude zřejmě problém, pokud se Alice s Bobem
    nachází na opačných koncích světa.}

    Kdyby ale existovala bezpečná síť, kterou by Eva nemohla
    odposlouchávat, jistě by mohli Alice s Bobem vést veškerou komunikaci rovnou přes ni.
    Tím pádem by se vůbec nepotřebovali domluvit na $k$, jelikož
    by nebylo potřeba zprávy šifrovat. Nebylo by tedy ani potřeba řešit problém, který byl představen v úvodu.

    K tomu, jak se Alice s Bobem mohou domluvit na tajném klíči $k$ i přes kanál, který 
    Eva odposlouchává, se dostaneme později (konkrétně v kapitole~\ref{sec:diffie-hellman}).
    Budeme k tomu potřebovat širší aparát znalostí.

    Nyní uvedeme některé základní příklady symetrických šifer.


\section{Caesarova šifra}
    Caesarova šifra $\mathcal{E}$ spadá do kategorie substitučních šifer.\footnote{Substituční šifra je druh šifry, při kterém dochází k záměně
    množiny symbolů za jinou množinu symbolů podle daného klíče.}
    $\mathcal{E}$ je definovaná nad $(\mathbb{N}_0,\Sigma^L,\Sigma^L)$, kde $\Sigma$
    je konečná množina symbolů a $L$ je libovolně zvolená délka.

    Pokud bychom symboly v abecedě oindexovali (tedy $\Sigma = \{a_0, a_1, \ldots, a_n\})$, funkce zašifrování $E$ by každý symbol zaměnila za
    symbol, který je v abecedě o $k$ míst dále. Symboly na konci abecedy bychom posunovali ve smyslu mod
    (např.: $E(2, y)= a$, $E(2, z)= b$ pro klasickou anglickou abecedu). Analogicky by 
    funkce dešifrování $D$ každý symbol zaměnila za symbol, který mu v abecedě o $k$ míst předchází.
    Vidíme, že takto zvolená šifra splňuje \emph{podmínku korektnosti}.

    \medskip

    Formálně můžeme zapsat:

    \begin{center}
        $E(k, a_i) = a_l$, kde $l = (i+k)\mod{|\Sigma|}$

        $D(k, a_j) = a_m$, kde $m = (j-k)\mod{|\Sigma|}$
    \end{center}

    Je jasné, že kdybychom chtěli zašifrovat celou zprávu $m$, tak podle klíče $k$ zašifrujeme všechny symboly jednotlivě na nové a
    jejich spojením vznikne zašifrovaná zpráva $c$.
    
    \bigskip
    Na okraj ještě uveďme, že se u klíčů můžeme omezit na podmnožinu nezáporných celých čísel a pracovat pouze s
    $\mathcal{K} =\{n \in \mathbb{N}_0 \mid n < |\Sigma|\}$
    bez újmy na obecnosti. Je zřejmé, že například pro množinu symbolů velikosti 2 by každý lichý klíč prohodil
    každý symbol na opačný a každý sudý klíč by nechal $m$ beze změny. Mohli bychom se tedy omezit pouze na $k \in \{0,1\}$
    aniž bychom jakkoliv změnili počet možností zašifrování zprávy $m$.
    Pro abecedu $\Sigma$ tedy obecně existuje $|\Sigma|$ klíčů, které zprávu $m$ zašifrují unikátním způsobem.\footnote{Krajní případ, kdy $m = c$
    uznáme jako platný, ikdyž by zřejmě nebyl prakticky využitelný.}

    \subsection{Bezpečnost Caesarovy šifry}

        Představme si nyní, že Alice a Bob spolu komunikují přes síť a využívají přitom Caesarovy šifry
        (pro zjednodušení uvažujme, že už jsou dohodnuti na společném klíči $k$).
        Je komunikace bezpečná?

        Pokud Eva zašifrovanou zprávu $c$ může číst, zřejmě její obsah nebude ihned zřetelný. Mohla by ale
        vyzkoušet všechny možnosti pro klíč $k$. Již jsme provedli úvahu o tom, že se s klíči můžeme omezit na
        $\{n \in \mathbb{N} \mid 0 \leq n < |\Sigma|\}$. Eva tedy může postupně vyzkoušet všechny tyto
        možnosti. Jedna z nich jistě bude správně dešifrovat $c$ a Eva si $m$ přečte.

        \medskip

        Pokud by Alice například chtěla Bobovi poslat zprávu v anglickém jazyce,
        stačilo by Evě otestovat 26 možností, jelikož anglická abeceda má pouze 26 znaků.
        Kdyby Alice chtěla Bobovi poslat zprávu skládající se z libovolných znaků ASCII, stačilo by
        Evě otestovat 128 možností.
        Kdyby Alice například posílala tajný číselný kód (přirozené číslo), stačilo by Evě vyzkoušet 10 možností.

        Obecně tedy k prolomení\footnote{Intuitivně chápeme jako proces, díky kterému bude Eva schopna získat dešifrované zprávy.}
        Caesarovy šifry stačí čas $O(|\Sigma|)$.\footnote{Tímto myslíme časovou složitost v nejhorším případě.
        Eva samozřejmě může v (pro ni) nejlepším případě klíč uhádnout hned na první pokus. Tomu samozřejmě nezabráníme žádnou šifrou.
        Můžeme včak vysokým počtem klíčů výrazně snížit pravděpodobnost, že se to stane.}

        K prolomení Caesarovy šifry lze také použít tzv. frekvenční analýzu, která umožňuje některé
        symboly odhadnout na základě jejich statistického výskytu v přirozeném jazyce.

        Je vidět, že Caesarova šifra je pro malou množinu znaků velmi snadno prolomitelná a tím pádem pro praktické problémy nevyužitelná.


\section{Vernamova šifra}

    % citace z Graduate Course ...

    Vernamova šifra (anglicky \emph{one-time pad}) spočívá v posunu každého znaku zprávy o náhodně zvolený počet míst v abecedě.
    Oproti Caesarově šifře tedy nemusí být shodné symboly posunuty vždy o stejný počet míst.

    Vernamova šifra $\mathcal{E}$ je definována nad $(\{0, 1, \ldots, |\Sigma|-1\}^L, \Sigma^L, \Sigma^L)$ pro zvolenou délku $L$.
    Klíč je tedy L-tice čísel, kde člen na pozici $i$ určuje počet míst v abecedě, o které posuneme znak zprávy na pozici $i$.

    \medskip

    Operace zašifrování a dešifrování jsou tedy definovány následovně:
    (předpokládejme, že $m_i = a_r$ a $c_j = a_s$)

    \begin{center}
        $E(k_i, m_i) = a_l$, kde $l = (r+k_i)\mod{|\Sigma|}$

        $D(k_j, c_j) = a_m$, kde $m = (s-k_j)\mod{|\Sigma|}$.
    \end{center}

    Obdobně jako u Caesarovy šifry bude zašifrování celé zprávy probíhat tak, že podle klíče $k$ zašifrujeme všechny znaky $m$ jednotlivě na nové a
    jejich spojením vznikne zašifrovaná zpráva $c$.

    \bigskip

    Existuje i binární varianta Vernamovy šifry, ve které jsou odesílané zprávy pouze sekvence bitů.
    Binární varianta je definována nad $(\{0,1\}^L, \{0,1\}^L, \{0,1\}^L)$.
    Fakt, že zprávy jsou sekvence bitů nás nijak neomezuje. Víme, že v praxi jsou všechny zprávy na nějaké úrovni
    reprezentovány sekvencí jedniček a nul.

    \medskip

    Operace šifry jsou pak definovány takto:

    \begin{center}
        $E(k, m) = k \oplus m$

        $D(k, c) = k \oplus c$
    \end{center}

    (symbol $\oplus$ značí operaci XOR aplikovanou po bitech)

    \bigskip
    Obě verze šifry zřejmě splňují \emph{podmínku korektnosti} (u binární varianty si stačí uvědomit, že $x \oplus x = 0^L$ pro každé $x \in \{0,1\}^L$).


    \subsection{Bezpečnost Vernamovy šifry}

        Pokud chceme zjistit, jak je Vernamova šifra bezpečná, zamysleme se nad tím, jak těžké ji bude prolomit.
        Eva by k získání původní zprávy $m$ z $c$ potřebovala zjistit klíč. Počet možných klíčů je počet binárních kódů délky $L$ (těch je $|\Sigma|^L$).

        K prolomení Vernamovy šifry je tedy potřeba čas $O(|\Sigma|^L)$. (Při použití binární varianty pro zprávu o velikosti 1 MB existuje $2^{8 \times 10^6}$ možných klíčů.)
        
        Platí také, že Vernamova šifra je odolná vůči frekvenční analýze, pokud pro zašifrování každé další zprávy vybereme náhodně nový klíč.
        Za předpokladu, že klíč $k$ je vybrán dokonale náhodně, a že klíč není použit opakovaně, je Vernamova šifra tzv.
        \emph{dokonale bezpečná}.

        % todo zopakovat problém pro nás kdyby útočník zjistil náš klíč (zpětně přečte veškerou konverzaci)




\section{Bezpečnost v teorii a praxi}
    
    Je jasné, že pro zajištění bezpečnosti šifry je nutné, aby byl $k$ vybrán z dostatečně velké množiny $\mathcal{K}$.
    Potom bude totiž pro Evu těžší zjistit použitý klíč $k$.

    Klíč $k$ musí být z množiny $\mathcal{K}$ vybrán dokonale náhodně (pravděpodobnost výběru každého z klíčů musí být stejná).
    Pokud by tomu tak nebylo, Eva by přirozeně nejprve vyzkoušela nejvíce pravděpodobné klíče.

    Je také nutné, aby $c$ byla nezávislá na $m$ a nijak s ní nesouvisela. Případná souvislost by Evě mohla zjednodušit získání $m$.

    \begin{remark}
        Riziko přináší také opakované použití stejného klíče.
        Pokud by napříč celou komunikací byl použit stejný klíč, útočník by mohl (například po náhodném získání klíče) zpětně
        dešifrovat každou zprávu, která komunikací prošla.
    \end{remark}

    \subsection*{Dokonalé zabezpečení}
    Jako zlatý standard, nebo ideál bezpečnosti se uvádí takzvané \emph{dokonalé zabezpečení}.\footnote{V anglicky psané
    literatuře se nejčastěji používá pojem \emph{perfect security}.}

    % [citace z Graduate Course ... str. 8, Def 2.1]

    \begin{definition}
        Dokonalé zabezpečení

        Nechť $\mathcal{E}=(E, D)$ je šifra definovaná nad trojicí $(\mathcal{K},\mathcal{M},\mathcal{C})$.
        Uvažujme pravděpodobnostní experiment, ve kterém je náhodná proměnná $\textbf{k}$ rovnoměrně rozdělena na $\mathcal{K}$.
        Pokud pro každé $m_0, m_1 \in \mathcal{M}$, a každé $c \in \mathcal{C}$ platí:

        \medskip
        $\Pr[E(\textbf{k},m_0) = c] = \Pr[E(\textbf{k},m_1) = c]$

        \medskip
        nazýváme $\mathcal{E}$ dokonale bezpečnou šifrou.
    \end{definition}

    Za předpokladu, že $\mathcal{E}$ je dokonale bezpečná a že každý klíč $k$ má stejnou pravděpodobnost
    výběru z $\mathcal{K}$ lze ukázat, že zpráva $c = E(k, m)$ bude nezávislá na $m$, což jak víme, je žádoucí.

    %[přesně citace? z Graduate Course ... str. 11, The 2.4]

    \begin{theorem}
        Vernamova šifra šifra je dokonale bezpečná.
    \end{theorem}

    %[citace z Graduate Course ... str. 9, The 2.2]

    \medskip
    
    Když tedy máme šifru, která je dokonale bezpečná, k čemu potřebujeme šifry ostatní? Důvodem je praxe.

    Prvním problémem je dokonale náhodný výběr klíče. Současné generátory nejsou dokonale náhodné, ale pouze pseudonáhodné.
    To nám ale pro potřeby bezpečnosti nestačí. (Eva by mohla využít pseudonáhodnosti k snazšímu uhádnutí klíče.)

    Tím druhým je paměťová náročnost. Pokud by si Alice s Bobem chtěli například poslat zprávu $m$ o velikosti 1 GB, museli by být předem
    domluveni na klíči $k$ stejné velikosti. Museli by tedy mít $k$ uložený někde v paměti. Vzhledem k tomu, že by
    pro každou zprávu Alice s Bobem potřebovali nový klíč, není nutnost takové velikosti vhodná.

    Následující věta nám ukazuje, že pokud chceme dosáhnout dokonalé bezpečnosti, musíme volit klíče alespoň stejné
    velikosti, jako jsou jimi šifrované zprávy. Tedy nedokážeme najít „stejně bezpečnou“ šifru, která by
    využívala klíče efektivněji než Vernamova šifra.

    \begin{theorem}[Shannonova věta]
        
        Nechť $\mathcal{E}  = (E, D)$ je šifra definovaná nad $(\mathcal{K},\mathcal{M},\mathcal{C})$.
        Je-li $\mathcal{E}$ dokonale bezpečná, potom $|\mathcal{K}| \geq |\mathcal{M}|$.
    \end{theorem}

    %[citace z Graduate Course ... str. 12, The 2.5]

    \medskip

    Díky předchozí větě můžeme snadno tvrdit, že Caesarova šifra není dokonale bezpečná.

    Zejména kvůli těmto dvěma problémům se v praxi vzdáváme jisté míry bezpečnosti za cenu toho, že jsme schopni zprávy šifrovat efektivněji.


\section{Modulární aritmetika}\label{sec:modular-arithmetic}

    [Obsah doplním následně po DH a RSA dle použitého obsahu, kterému tuto kapitolu přizpůsobím.
    Případně věty rozdělím přímo ke kapitolám, u kterých jsou využity.]

    V této kapitole uvedeme několik definic a vět, které nám pomůžou v dalších pasážích tohoto textu.
    Na některé z nich budeme přímo odkazovat.
    
    % todo co musi ctenar vedet
    U čtenáře předpokládáme základní znalosti z teorie grup, kongruence modulo $n$ a dělitelnosti.

    
    % dusledky pro Zp
    % multiplikativni grupa (grupa Zmod n vyhledem k nasobeni)


    % zdroj A Graduate Course... úplně nakonci Appendix A

    % Cyklicnost a generatory

    \begin{definition}
        Grupa $G$ se nazývá cyklická, jestliže existuje prvek $g \in G$ takový, že $G =\{g^k \mid k \in \mathbb{Z}\}$.
        Prvek $g$ se nazývá generátor cyklické grupy.
    \end{definition}

    \begin{definition}
        Řád prvku $a$ v grupě $G$ je nejmenší přirozené číslo $b$ takové, že $a^b = e$, kde $e$ je neutrálním prvkem grupy $G$.
    \end{definition}


    \begin{theorem}[Lagrangova věta]
        
        Nechť $H$ je podgrupa grupy $G$. Pak $|H|$ dělí $|G|$.
    \end{theorem}

    \begin{consequence}
        Řád každého prvku $a \in G$ dělí řád grupy $G$.
    \end{consequence}

    


    \begin{theorem}[Cauchyho věta]

        Nechť $G$ je konečná grupa řádu $n$ a $p$ je prvočíslo.
        Pokud $p$ dělí $n$, pak v G existuje prvek (a tedy i cyklická podgrupa) řádu $p$.

    \end{theorem}

    \begin{consequence}\label{con:prime-cyclic}
        Každá grupa prvočíselného řádu je cyklická.
    \end{consequence}



    \begin{definition}\label{def:Z*p}
        Multiplikativní grupu nenulových zbytkových tříd modulo $p$ budeme značit $\mathbb{Z}^*_p$.
    \end{definition}

    \begin{theorem}
        Pro libovolné prvočíslo $p$ je $\mathbb{Z}^*_p$ cyklická.
    \end{theorem}

    \begin{definition}
        Neutrální prvek multiplikativní grupy budeme nazývat \emph{jednička}.
    \end{definition}



    % Euler

    \begin{definition}
        Eulerova funkce $\varphi: \mathbb{N} \rightarrow \mathbb{N}$ přiřazuje každému přirozenému číslu $n$
        počet přirozených čísel menších nebo rovno $n$, která jsou s $n$ nesoudělná, tedy

        \begin{center}
            $\varphi(n) = |K|$, kde $K = \{k \in \mathbb{N} \mid k \leq n; NSD(k,n)=1\}$.
        \end{center}

    \end{definition}

    \begin{theorem}\label{the:generators-count}
        Každá konečná cyklická grupa řádu n má právě $\varphi(n)$ různých generátorů, kde $\varphi$ je Eulerova funkce.
    \end{theorem}

    \begin{consequence}\label{con:generators-count}
        Každá konečná cyklická grupa prvočíselného řádu $p$ má $p-1$ různých generátorů.
    \end{consequence}



\section{Diffieho-Hellmanova výměna klíčů}\label{sec:diffie-hellman}

    % citace z Graduate Course ... str 406
    % RSA and public ... str 49

    % todo analogie s mícháním barev

    V úvodu k symetrickému šifrování jsme zmínili, že výměna (respektive domluva)
    tajného klíče $k$ mezi Alicí a Bobem tak, aby jej nezískala Eva, není jednoduchý úkol.

    S pomocí některých znalostí, které jsme uvedli v sekci~\ref{sec:modular-arithmetic}, zmíníme protokol, pomocí kterého
    to bude možné.

    Jeho idea stojí na myšlence \emph{jednosměrných funkcí}. Jednosměrná funkce $F$ je taková funkce, kde pro každý vstup $x$ lze
    snadno spočítat $F(x)$, ale z $F(x)$ nelze snadno zjistit původní $x$.\footnote{Jako praktický příklad se často uvádí smíchání dvou barev.
    Dvě různé barvy lze snadno smíchat a následně zjistit barvu, která vznikne.
    Z výsledné barvy samotné ale zřejmě není jednoduché zjistit barvy, jejichž smícháním vznikla.}
    Jinými slovy, není snadné k funkci $F$ najít inverzní funkci $F^{-1}$.

    \medskip

    Celý protokol pak bude probíhat obecně takto:
    
    \begin{itemize}
        \item
            Alice náhodně vygeneruje svůj tajný klíč $\alpha$ a spočítá $H(\alpha)$.
            To stejné provede Bob pro svůj náhodně vygenerovaný tajný klíč $\beta$.
        \item
            Alice a Bob si přes síť vymění $H(\alpha)$ a $H(\beta)$.
        \item
            Alice s pomocí svého tajného klíče $\alpha$ a obdrženého $H(\beta)$ vypočítá $C(\alpha,\beta)$.
            Stejně učiní Bob se svým tajným klíčem $\beta$ a obdrženého klíče $H(\alpha)$.
        \item
            Alice a Bob v komunikaci použijí $k = C(\alpha,\beta)$ jako jejich společný tajný klíč.
    \end{itemize}

    Aby protokol fungoval korektně a efektivně, požadujeme následující:

    \begin{enumerate}
        \item
            Pro každý vstup $x$ lze $H(x)$ snadno spočítat.
        \item
            Z $\alpha$ a $H(\beta)$ lze snadno spočítat $C(\alpha,\beta)$.
        \item
            Z $\beta$ a $H(\alpha)$ lze snadno spočítat $C(\alpha,\beta)$.
        \item
            Z $H(\alpha)$ a $H(\beta)$ nelze snadno spočítat $C(\alpha,\beta)$.
    \end{enumerate}

    Tyto podmínky implikují to, že $H$ musí být jednosměrná funkce.
    Za splnění těchto podmínek platí, že Alice i Bob s pomocí protokolu efektivně získají
    stejný klíč $k$ (to plyne přímo z podmínky 2 a 3).

    \medskip

    Teď jen stačí nalézt vhodné funkce $H$ a $C$ tak, aby splňovaly podmínky.

    \medskip

    Pro vhodně vybraný generátor $g$ zvolme:

    \begin{center}
        $H(x) = g^x$

        $C(x, y) = (g^x)^y$.

        \medskip
    \end{center}

    Tyto funkce už zřejmě splňují podmínky 1--3. Abychom předešli tomu, že vygenerovaný klíč bude příliš velký
    (což jak víme není vhodné), budeme pracovat s adekvátní konečnou algebraickou doménou.

    Ke splnění podmínky 4 tedy musí platit, že funkce $H^{-1}$ je výpočetně náročná.
    Tou bude v našem případě funkce \emph{diskrétního logaritmu}.


    \subsection{Protokol D-H}

        Alice a Bob se nejprve musí domluvit na velkém prvočísle $p$ (to bude určovat potřebnou konečnou doménu).
        Prvočíslo $p$ by mělo být alespoň 2048 bitů dlouhé.
        Zároveň by mělo platit, že existuje prvočíslo $q$ (alespoň 256 bitů dlouhé), které dělí $p-1$.
        K tomu, proč je existence $q$ důležitá se budeme věnovat v podkapitole~\ref{sub:silver-pohlig-hellman}.

        Pro funkčnost protokolu potřebujeme, aby Alice i Bob znali generátor $g$ grupy $\mathbb{Z}^*_p$ (viz~\ref{def:Z*p}).
        Nalezení generátoru grupy není obecně jednoduchý úkol.
        Budeme ale předpokládat, že $g$ je parametr sdílený všemi uživateli v síti (i Evou).

        \begin{remark}
            Generátorem grupy $\mathbb{Z}^*_p$ \textbf{není} její libovolný prvek různý od jedničky.
            Grupa $\mathbb{Z}^*_p$ je řádu $p-1$, neplatí pro ni tedy Důsledek~\ref{con:generators-count}.
        \end{remark}

        \begin{enumerate}
            \item
                Alice pošle Bobovi velké prvočíslo $p$.
                Domluvit se můžou i nezabezpečenou komunikací přes síť. Nevadí nám, že Eva $p$ zachytí.
            \item
                Alice náhodně vybere (velké) číslo $\alpha \in \mathbb{N}$, vypočítá $A=g^\alpha \mod{p}$ a $A$ pošle po síti Bobovi.
            \item
                Bob náhodně vybere (velké) číslo $\beta \in \mathbb{N}$, vypočítá $B=g^\beta \mod{p}$ a $B$ pošle po síti Alici.
            \item
                Alice vypočítá $k=B^\alpha \mod{p}$.
            \item
                Bob vypočítá $k=A^\beta \mod{p}$.

        \end{enumerate}

        Všimněme si, že $B^\alpha \equiv g^{\beta \alpha} \pmod{p}$ a $A^\beta \equiv g^{\alpha \beta} \pmod{p}$. Z komutativity násobení
        plyne, že $g^{\beta \alpha} = g^{\alpha \beta}$. Z tohoto vyplývá, že Alice a Bob nezávisle na sobě získají stejný klíč $k$.


    \subsection{Bezpečnost D-H výměny klíčů}\label{sub:diffie-hellman-security}

        Celou komunikaci na síti poslouchá Eva. Z návrhu našeho protokolu víme, že Eva zachytila $p, A$ (tedy $g^\alpha$) a $B$ (tedy $g^\beta$).
        Navíc zná generátor $g$.
        Jestliže chce Eva šifrované zprávy dešifrovat, musí získat $k$.
        Musí tedy zjistit $g^{\alpha \beta}$ z $g, g^\alpha, g^\beta$ (aniž by znala $\alpha$ nebo $\beta$).
        Tomuto problému budeme říkat \emph{Diffieho-Hellmanův problém} (zkráceně DHP).

        % [todo zadefinovat DHP a souvislost DLP nechat na později?]

        Platí, že Eva je schopna vyřešit DHP, pokud umí vyřešit tzv. \emph{problém diskrétního logaritmu}.
        Ikdyž opačná implikace zatím nebyla dokázána, panuje shoda, že oba zmíněné problémy jsou ekvivalentní.

        Bezpečnost D-H výměny klíčů se tedy výrazně opírá o složitost řešení problému diskrétního logaritmu.
        Tomu, za jakých podmínek jej považujeme za obtížně řešitelný (a tedy D-H výměnu jako bezpečnou), se budeme věnovat v následující kapitole.
    

\section{Problém diskrétního logaritmu}\label{sec:discrete-log}
    

        V podkapitole~\ref{sub:diffie-hellman-security} jsme představili problém DHP.
        Úkolem bylo zjistit $g^{\alpha \beta}$ z $g, g^\alpha, g^\beta$ bez znalosti $\alpha$ a $\beta$.

        Pokud bychom byli schopni z $g^\alpha$ efektivně získat $\alpha$ (případně z $g^\beta$ získat $\beta$), uměli bychom také
        efektivně řešit DHP.

        \begin{definition}[Problém diskrétního logaritmu (DLP)]\label{def:dlp}
            
            Nechť $\mathbb{G}$ je cyklická grupa řádu $n$, $g$ její generátor a $x$ libovolný prvek z $\mathbb{G}$.

            Číslo $e \in \mathbb{Z}_n$ takové, že

                \begin{equation}\label{eq:discrete-log}
                    g^e \equiv x \pmod{n}.
                \end{equation}
            
            nazveme diskrétním logaritmem o základu $g$ z $x$.

            Nalezení takového čísla $e$ budeme nazývat \textbf{problém diskrétního logaritmu}.

        \end{definition}
        
        Existuje řada grup $\mathbb{G}$, u nichž předpokládáme, že je v nich problém diskrétního logaritmu obtížně řešitelný.
        Na tomto předpokladu stojí bezpečnost řady šifrovacích protokolů, včetně Diffieho-Hellmanovy výměny klíčů
        (jak jsme uvedli v sekci~\ref{sub:diffie-hellman-security}).

        % attack game 10.4 A Graduate Course - 407

        \begin{definition}[Předpoklad diskrétního logaritmu]\label{def:discrete-log-assumption}
                        
            Předpoklad diskrétního logaritmu platí pro cyklickou grupu $\mathbb{G}$, právě tehdy když
            je pravděpodobnost správného určení diskrétního logaritmu zanedbatelná. 

        \end{definition}

        V následujících podkapitolách se zaměříme na volbu grupy $\mathbb{G}$ a vliv jejích
        vlastností na obtížnost DLP. Předem jen uveďme, že obtížnost DLP je úzce provázána s prvočísly.


        \subsection{Obtížnost DLP}\label{sub:discrete-log-complexity}

        V současnosti se za vhodnou volbu $\mathbb{G}$ považuje grupa řádu $n=p$, kde
        $p$ je velké prvočíslo (alespoň 2048 bitů dlouhé). Pro $p$ také musí platit, že číslo $p-1$ má alespoň
        jednoho velkého prvočíselného dělitele $q$ (alespoň 256 bitů).

        \begin{remark}
            Prvočíselný řád grupy $\mathbb{G}$ nám automaticky zaručuje cykličnost (viz Důsledek~\ref{con:prime-cyclic}).
        \end{remark}

        Složitost nalezení diskrétního logaritmu $x$ v grupě řádu $p$, kde $p$ má $k$ číslic, je prakticky
        stejná jako faktorizace $k$-ciferného celého čísla.
        Díky tomu můžeme říct, že výpočet diskrétních logaritmů je zhruba stejně obtížný jako faktorizace.
        Pro faktorizaci (stejně jako pro DLP) není znám žádný polynomiální algoritmus, který by ji řešil.

        % [citace] P. van Oorschot, A comparison of practical public-key cryptosystems based on integer factorization and discrete logarithms, in Contemporary Cryptography The Science of Information Integrity, G. Simmons, ed., IEEE Press, Piscatoway, New Jersey (1992), 289–322.

        Je třeba zdůraznit, že jsme zatím ani nedokázali, že takový algoritmus neexistuje.\footnote{Tento fakt souvisí s problémem
        $P$ versus $NP$. Ten patří k nejznámějším otevřeným problémům teoretické informatiky.}


        \subsection{Výpočet diskrétního logaritmu}\label{sub:computing-discrete-log}

        % Graduate Course... 409, 680-687

        \subsection{Hrubá síla}\label{sub:brute-forcing-discrete-log}
            Nejjednodušším způsobem k nalezení diskrétního logaritmu je hrubá síla.
            Algoritmus pracující tímto přístupem jednoduše vyzkouší všechny možné exponenty,
            dokud nenajde exponent $e$ vyhovující~(\ref{eq:discrete-log}).
            
            \begin{kicode}{TeX}{}{Nalezení diskrétního logaritmu hrubou silou}
                function brute_force_dlog(base, result, modulus):

                exponent = 0

                while result != current_result:

                    current_result = pow(base, exponent, modulus)
                                    
                    exponent += 1
        
            \end{kicode}

            Takto navržený algoritmus je korektní. V nejhorším případě potřebuje provést $n$ násobení v grupě $\mathbb{G}$.


        % Graduate Course 686
        % RSA... 39-40
        \subsection{Silver-Pohlig-Hellmanův algoritmus}\label{sub:silver-pohlig-hellman}

            Dle \emph{základní věty aritmetiky} [TODO znění] lze každé přirozené číslo větší než 1 jednoznačně rozložit na součin prvočísel.
            Nechť $n$ je řád grupy $\mathbb{G}$ a

                \begin{equation}\label{eq:factorization}
                    n=q_1^{e_1} \cdots q_r^{e_r}
                \end{equation}

            je jeho faktorizace na součin $r$ různých prvočísel.

            \medskip

            Způsob pro nalezení $e \in \mathbb{Z}_n$ vyhovující~(\ref{eq:discrete-log}) je následující:

            \bigskip
            
            [TODO PROMYSLET KÓD] - kód naznačit zde / pouze programovat

            \bigskip

            Pokud je faktorizace~(\ref{eq:factorization}) dána, časová složitost Silver-Pohlig-Hellmanova algoritmu je

                \begin{equation}\label{eq:sph-complexity}
                    \sum_{i=1}^r O(e_i T(q_i) + e_i \log{e_i} \log{q_i}) = O(T(q_{max}) \log{n} + \log{n} \log \log{n}).
                    \footnote{Předpokládáme, že operaci násobení v grupě provádíme v konstantním čase.}
                \end{equation}
            
    
            Funkce $T(q_i)$ označuje počet násobení v grupě, které musí být provedeny pro zjištění diskrétního logaritmu
            v podgrupě $\mathbb{G}$ řádu $q_i$. Hodnota $q_{max}$ značí největší prvočíslo.

            Ze složitosti~(\ref{eq:sph-complexity}) získáváme několik důležitých faktů.

            \begin{theorem}\label{the:sph-complexity}
                Složitost výpočtu diskrétního logaritmu v cyklické grupě řádu $n$ je dána velikostí největšího prvočísla, které dělí $n$.
            \end{theorem}

            Tato věta jasně určuje, v jakých grupách platí předpoklad diskrétního logaritmu (viz~\ref{def:discrete-log-assumption}).

            \begin{consequence}
                Aby platil předpoklad diskrétního logaritmu v grupě $\mathbb{G}$, její řád musí mít alespoň
                jednoho velkého prvočíselného dělitele.
            \end{consequence}

            Pokud bychom například chtěli spočítat diskrétní logaritmus v grupě $\mathbb{G}$ s řádem $n = 2^l$, bude
            nám stačit provést $O(\log n \cdot \log \log n)$ násobení v grupě.

            \medskip

            Kdyby se tedy například Alice s Bobem u D-H výměny klíčů domluvili na prvočísle $p$ ve tvaru $p = 2^l + 1$,
            Evě by pro prolomení celé komunikace stačilo spočítat diskrétní logaritmus v grupě $\mathbb{Z}^*_p$.
            Grupa $\mathbb{Z}^*_p$ by v tomto případě byla řádu $2^l$.
            Výpočet diskrétního logaritmu (a tedy i získání tajného klíče $k$) by tedy pro Evu byl snadný úkol. 


            \begin{remark}[Zefektivnění protokolu D-H]\label{rem:diffie-hellman-improved}
                
                Složitost Silver-Pohlig-Hellmanova algoritmu také dává návod pro zefektivnění D-H protokolu.
                Namísto spuštění D-H protokolu v celé grupě $\mathbb{Z}^*_p$ stačí protokol spustit
                v podgrupě $\mathbb{G}_{q_{max}}$ řádu $q_{max}$.
            
                Dle Věty~\ref{the:sph-complexity} takovéto omezení bude mít pouze zanedbatelný vliv na bezpečnost protokolu.

                Alici i Bobovi tímto omezením zmenšíme množinu exponentů, ze kterých budou vybírat své tajné klíče.

            \end{remark}


        \subsection{Kvantové útoky na DLP}

            [TODO]
    


\section{Napadení protokolu D-H trochu jinak}


    V části~\ref{introduction} jsme uvedli, že Eva umí komunikaci proudící po síti pouze číst. Eva tedy nemůže zprávy posílat, mazat, ani modifikovat.
    Pokud se v síti nachází protivník, který takové schopnosti má, stává se námi uvedený protokol snadno napadnutelným. Protivníka, který bude mít
    schopnost posílat, mazat a modifikovat zprávy v síti, nazveme Mallory.\footnote{Jméno Mallory (z angl. \emph{malicious attacker}) se nejčastěji používá jako
    označení útočníka, který je (oproti Evě) aktivní.}

    \bigskip

    Ukažme si, jak by Mallory mohl komunikaci mezi Alicí a Bobem jednoduše napadnout.
    Alice s Bobem se chtějí domluvit na tajném klíči $k$ (kterým budou šifrovat zprávy) pomocí protokolu D-H.

        \begin{itemize}
            \item
                Alice pošle Bobovi velké prvočíslo $p$.
                Mallory $p$ zachytí a zapamatuje si ho.
            \item
                Alice náhodně vybere (velké) číslo $\alpha \in \mathbb{N}$, vypočítá $A=g^\alpha \mod{p}$ a $A$ pošle po síti Bobovi.
            \item
                Mallory zprávu $A$ zachytí a nepošle ji dále Bobovi. Místo toho vybere velké číslo $\gamma \in \mathbb{N}$,
                vypočítá $C=g^\gamma \mod{p}$ a $C$ pošle po síti Bobovi.
            \item
                Bob náhodně vybere (velké) číslo $\beta \in \mathbb{N}$, vypočítá $B=g^\beta \mod{p}$ a $B$ pošle po síti Alici.
            \item
                Mallory zprávu $B$ zachytí a nepošle ji Alici. Místo toho Alici pošle $C$.
            \item
                Alice vypočítá $k_1=C^\alpha \mod{p}$. Bob vypočítá $k_2=C^\beta \mod{p}$.
            \item
                Mallory vypočítá $k_1=A^\gamma \mod{p}$ a $k_2=B^\gamma \mod{p}$.

        \end{itemize}

        % todo [obrázek]

        Alice a Bob si nyní můžou myslet, že se dohodli na společném klíči, pomocí kterého povedou zabezpečenou komunikaci.
        Ve skutečnosti bude ale jejich veškerou komunikaci číst (případně měnit) Mallory, aniž by o tom Alice s Bobem věděli.
        Ukažme si to na příkladu komunikace, která probíhá po výše zmíněné výměně klíče.

        Alice pomocí $k_1$ zašifruje zprávu $m$ a pošle $c$ po síti Bobovi. Mallory $c$ zachytí a pomocí $k_1$ ji dešifruje.
        Zprávu $m$ si nyní může přečíst a kompletně změnit její obsah.
        Upravenou zprávu $m'$ zašifruje pomocí $k_2$ a $c'$ pošle Bobovi.\footnote{Pokud Mallory zprávy pouze čte, potom zřejmě $m = m'$.}
        Bob zprávu $c'$ dešifruje pomocí $k_2$.

        Problém je jistě v autentifikaci zpráv. Alice ani Bob nemají možnost zjistit, že byla zpráva někým upravena.
        Bob nemá nikdy jistotu, že obdrženou zprávu poslala opravdu Alice (a naopak).

        \medskip

        Šifrovací metody, které autentifikaci zajišťují (a budou tedy komunikaci chránit i před Mallorym), představíme v části~\ref{public-key}.

    \newpage
    
\part{Asymetrické šifrování}\label{public-key}



\end{document}